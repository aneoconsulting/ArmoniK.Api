syntax = "proto3";

import "objects.proto";
import "task_status.proto";
import "session_status.proto";
import "result_status.proto";

option csharp_namespace = "ArmoniK.Api.gRPC.V1";
package ArmoniK.api.grpc.v1;

service Submitter{
	rpc GetServiceConfiguration (Empty) returns (Configuration); 

	rpc CreateSession (CreateSessionRequest) returns (CreateSessionReply);
	rpc CancelSession (Session) returns (Empty);

	rpc CreateSmallTasks (CreateSmallTaskRequest) returns (CreateTaskReply);
	rpc CreateLargeTasks (stream CreateLargeTaskRequest) returns (CreateTaskReply);

	rpc ListTasks (TaskFilter) returns (TaskIdList);
	rpc ListSessions (SessionFilter) returns (SessionIdList);

	rpc CountTasks (TaskFilter) returns (Count);
	rpc TryGetResultStream (ResultRequest) returns (stream ResultReply);
	rpc TryGetTaskOutput (ResultRequest) returns (Output);
	rpc WaitForAvailability (ResultRequest) returns (AvailabilityReply);
	rpc WaitForCompletion (WaitRequest) returns (Count);
	rpc CancelTasks (TaskFilter) returns (Empty); 
	rpc GetTaskStatus (GetTaskStatusRequest) returns (GetTaskStatusReply);
	rpc GetResultStatus (GetResultStatusRequest) returns (GetResultStatusReply);

  /**
   * This endpoint allows a user to watch a list of results and be notified when there is any change.
   * The user sends the list of ids they want to watch.
   * The submitter will then send the statuses for all requested ids immediately and keep the stream open.
   * The submitter will send updates to the client via the opened stream.
   * Any reply can be implicitely chunked if there are too many event to report at the same time (or for the first reply).
   * It is possible to filter out specific statuses from events with options
   */
  rpc WatchResults (WatchResultRequest) returns (stream WatchResultStream);
}


message Session {
	string id = 1;
}

message SessionList {
  repeated Session sessions = 1;
}

message SessionIdList {
  repeated string session_ids = 1;
}

message CreateSessionRequest {
	string id = 1;
	TaskOptions default_task_option = 3;
}

message CreateSessionReply {
	oneof result {
		Empty ok = 1;
		string error = 2;
	}
}


message CreateSmallTaskRequest {
	string session_id = 1;
	TaskOptions task_options = 2;
	repeated TaskRequest task_requests = 3;
}

message CreateLargeTaskRequest {
	message InitRequest {
		string session_id = 1;
		TaskOptions task_options = 2;
	}
	oneof type {
		InitRequest init_request = 1;
		InitTaskRequest init_task = 2;
		DataChunk task_payload = 3;
	}
}

message TaskFilter {
	message IdsRequest {
		repeated string ids = 1;
	}
	message StatusesRequest {
		repeated TaskStatus.TaskStatus statuses = 1;
	}
	oneof ids {
		IdsRequest session = 1;
		IdsRequest task = 3;
	}
	oneof statuses {
		StatusesRequest included = 4;
		StatusesRequest excluded = 5;
	}
}

message SessionFilter {
  repeated string sessions = 1;
  
  message StatusesRequest {
    repeated SessionStatus.SessionStatus statuses = 1;
  }
  
  oneof statuses {
    StatusesRequest included = 4;
    StatusesRequest excluded = 5;
  }
}

message GetTaskStatusRequest {
	repeated string task_ids = 1;
}

message GetTaskStatusReply {
	message IdStatus {
		string task_id = 1;
		TaskStatus.TaskStatus status = 2;
	}
	repeated IdStatus id_statuses = 1;
}

message GetResultStatusRequest {
	repeated string result_ids = 1;
	string session_id = 2;
}

message GetResultStatusReply {
	message IdStatus {
		string result_id = 1;
		ResultStatus.ResultStatus status = 2;
	}
	repeated IdStatus id_statuses = 1;
}

message ResultReply {
	oneof type {
		DataChunk result = 1;
		TaskError error = 2;
		string not_completed_task = 3;
	}
}

message AvailabilityReply {
	oneof type {
		Empty ok = 1;
		TaskError error = 2;
		string not_completed_task = 3;
	}
}

message WaitRequest {
	TaskFilter filter = 1;
	bool stop_on_first_task_error = 2;
	bool stop_on_first_task_cancellation = 3;
}

/**
 * Request to watch result states
 * It contains the list of result ids you want to watch
 *   and some options to filter out some events
 */
message WatchResultRequest {
  message Options {
    // List of statuses to ignore in the replies
    optional repeated ResultStatus ignore_statuses = 1;
    // Skip the sending of result states at the beginning
    optional bool skip_current_state = 2;
  }
  // List of result ids to watch
  repeated string result_ids = 1;

  // Options
  optional Options options = 2;
}

/**
 * List of Result statuses
 */
message WatchResultStream {
  // Key-Value pair for result id and its status
  message ResultIdStatus {
    // Id of the result
    string result_id = 1;
    // Status of the result
    ResultStatus status = 2;
  }

  // List of result ids and their statuses
  repeated ResultIdStatus statuses = 1;
  // List of ids that were not found
  // Required in stream mode
  repeated string not_found_ids = 2;
}
